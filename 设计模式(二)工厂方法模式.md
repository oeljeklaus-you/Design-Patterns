# 设计模式(二):工厂方法模式

## 模式动机

​	在简单工厂模式中，如果在原来的实现的基础上，我们再增加一个产品类的实现，那么我们必须在原来的工厂方法里修改工厂类的源代码.那么有没有更好的方法，可以不修改工厂类的源代码而进行动态的可扩展呢?今天我们将要介绍的设计模式之工厂方法模式，就是这样的一个很好的设计思路:将工厂类进行抽象，根据不同的产品创建不同的工厂类，如果动态的增加了一个产品，我们只需要实现这个产品的具体类的工厂类即可。

## 模式定义

​	工厂方法模式也称为工厂模式，属于创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

## 模式结构

工厂方法模式包含如下角色：

​	Product：抽象产品

​	ConcreteProduct：具体产品

​	Factory：抽象工厂

-  ConcreteFactory：具体工厂

![image-20180714133844401](/Users/youyujie/Documents/Java知识点复习图片/工厂方法模式类图.png)

## 时序图

![image-20180714133947402](/Users/youyujie/Documents/Java知识点复习图片/工厂方法模式时序图.png)

## 代码示例

这里我们通过一个具体的实例来进行讲解，在我们编写程序的过程中，我们经常会遇到各种日志，有文件的日志，数据库的日志等。我们这里创建两个抽象的类Log和LogFactory

```java
package cn.edu.hust.factory;

public abstract class Log {
    public abstract void writeLog();
}

```

```java
package cn.edu.hust.factory;

public abstract class LogFactory {
    public abstract Log createLog();
}

```

接下来就是创建Log的实现类:

```java
package cn.edu.hust.factory;

public class FileLog extends Log{
    public void writeLog() {
        System.out.println("文件日志。。。。");
    }
}

```

```java
package cn.edu.hust.factory;

public class FileLog extends Log{
    public void writeLog() {
        System.out.println("文件日志。。。。");
    }
}

```

然后就是生产两种日志的工厂类:

```java
package cn.edu.hust.factory;

public class FileLogFactory extends LogFactory{

    public Log createLog() {
        return new FileLog();
    }
}

```

```java
package cn.edu.hust.factory;

public class DataBaseLogFactory extends LogFactory{
    public Log createLog() {
        return new DataBaseLog();
    }
}

```

在实际的应用中，我们根据需求使用不同的工厂生产出不同的对象。这里，如果要有一个WebLog类，我们可以继承Log类，然后创建一个WebLogFactory，只是动态的扩展不需要修改任何的系统代码。

## 工厂模式优点

- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
- 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。

## 工厂模式缺点

- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

## 试用场景

在以下情况下可以使用工厂方法模式：

- 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
- 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。